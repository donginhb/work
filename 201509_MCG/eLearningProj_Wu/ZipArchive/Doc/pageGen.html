<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ZipArchive: General Information</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff" leftmargin="32" marginwidth="32" topmargin="32" marginheight="32">
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="pageGen">General Information</a></h1><dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectCompress">Compression and decompression</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectSpan">Multi-disk archives</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectPass">Password encryption and decryption</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectSE">Self extract support</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectExc">Exceptions</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectMemory">Creating and extracting archives from/in memory</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectCallb">Action progress notifications (callbacks)</a> </dd></dl>
<dl compact><dt><b></b></dt><dd><a class="el" href="pageGen.html#sectHelp">Integrating with MSDN</a> </dd></dl>
<dl compact><dt><b></b></dt><dd></dd></dl>
<h2><a class="anchor" name="sectCompress">
Compression and decompression</a></h2>
There are some functions defined for fast operations on archive: <a class="el" href="classCZipArchive.html#a13">CZipArchive::AddNewFile</a>, <a class="el" href="classCZipArchive.html#a25">CZipArchive::ExtractFile</a>, <a class="el" href="classCZipArchive.html#a34">CZipArchive::DeleteFile</a>, <a class="el" href="classCZipArchive.html#a29">CZipArchive::TestFile</a>. You only need to call functions <a class="el" href="classCZipArchive.html#a9">CZipArchive::Open</a> - before and <a class="el" href="classCZipArchive.html#a46">CZipArchive::Close</a> - after using them. Calling <a class="el" href="classCZipArchive.html#a46">CZipArchive::Close</a> function after you've done modifying the archive is necessary for the archive to be intact.<h2><a class="anchor" name="sectSpan">
Multi-disk archives</a></h2>
This library can create multi-disk archives in two ways (modes):<p>
<a class="anchor" name="PKSpan"></a><ul>
<li><b>PKSpan</b> mode. Disk spanning on removable media:<ul>
<li>the archive can only be created on a removable device,</li><li>the size of the volume is auto-detected</li><li>the label is written to the disk</li><li>you need to define a callback functor for changing disks and set it with <a class="el" href="classCZipArchive.html#a8">CZipArchive::SetSpanCallback</a> function.</li></ul>
</li></ul>
<p>
<a class="anchor" name="TDSpan"></a><ul>
<li><b>TDSpan</b> mode. Disk spanning on non-removable media:<ul>
<li>the archive can be created on non-removable device as well</li><li>you need to define a single volume size</li><li>there is no need to set callback functor in this mode.</li></ul>
</li></ul>
<p>
These two disk spanning modes create volumes with compatible internal structure. It means that you can easily convert the volumes created in one mode to the other one by renaming the files (in TDSpan mode each volume's extension (apart from the last one) consists of a 'z' letter and a number). To convert the archive from TD to PKZIP compatible archive, copy each file to the removable media, giving them the extension ".zip". You should also label each disk with the appropriate label starting from "pkback# 001" (note the space between '#' and '0').<p>
There is a limited functions set available while working with multi-disk archives. Only adding is allowed when creating the archive and only extracting and testing after opening an existing one. Deleting files from these archives is not allowed at all.<p>
Class <a class="el" href="classCZipArchive.html">CZipArchive</a> uses write buffer to make write operations as fast as possible. You can change its size with <a class="el" href="classCZipArchive.html#a4">CZipArchive::SetAdvanced</a> function (first argument). While creating a multi-disk archive, set the size of the buffer to the maximum size of the volume for the best performance.<p>
Popular archivers such as PKZIP and WinZip should be able to open the archive created in both modes.<h2><a class="anchor" name="sectPass">
Password encryption and decryption</a></h2>
This library supports creating and extracting the password protected archives. There are several issues you should be aware of when using this feature. To set the password for the file to be added or extracted call the function <a class="el" href="classCZipArchive.html#a2">CZipArchive::SetPassword</a> with the password as the argument. To clear the password call this function without arguments or with an empty string argument. The function has no effect on a closed archive and on the currently opened file (whether new or existing) inside archive. During opening the archive the password is cleared. You can set different passwords for different files inside the same archive, but remember to set it BEFORE opening the file. You cannot use ASCII characters with codes above 127 in the password, if you do so, the function <a class="el" href="classCZipArchive.html#a2">CZipArchive::SetPassword</a> returns false and the password is cleared. You can find out what files are password encrypted by calling <a class="el" href="classCZipArchive.html#a44">CZipArchive::GetFileInfo</a>, which fills the structure <a class="el" href="classCZipFileHeader.html">CZipFileHeader</a> with data, and then call the method ZipFileHeader::IsEncrypted. If it returns true, the file needs a password to extract. The successful extraction of the encrypted file doesn't always mean that the password is correct. You also need to check the return value of <a class="el" href="classCZipArchive.html#a32">CZipArchive::CloseFile</a>. You could also check the size of the extracted file since it can be smaller than it should be in case of the bad password.<h2><a class="anchor" name="sectSE">
Self extract support</a></h2>
The library is capable of extracting and modifying self-extracting archives. You can create your own SFX archive as well. This is the simplest code responsible for the self-extracting:<p>
<div class="fragment"><pre class="fragment"><span class="comment">//Windows code</span>

<span class="keywordtype">int</span> APIENTRY WinMain(HINSTANCE hInstance,
HINSTANCE hPrevInstance,
LPSTR lpCmdLine,
<span class="keywordtype">int</span> nCmdShow)
{
 <a class="code" href="classCZipArchive.html">CZipArchive</a> zip;

 <span class="comment">// get the path of the executable</span>
 TCHAR szBuff[_MAX_PATH];
 <span class="keywordflow">if</span> (!::GetModuleFileName(hInstance, szBuff, _MAX_PATH))
  return -1;

 CZipString szDest;
 <span class="comment">// ...</span>
 <span class="comment">// add some code here to get the destination directory from the user </span>
 <span class="comment">// for example:</span>
 <span class="comment">// CBrowseForFolder bf;</span>
 <span class="comment">//   bf.strTitle = _T("Select directory to extract files");</span>
 <span class="comment">//   if (!bf.GetFolder(szDest))</span>
 <span class="comment">//       return -1;</span>
 <span class="comment">//</span>
 <span class="comment">// class CBrowseForFolder is included in the sample application project</span>
 <span class="comment">// remember about including the header!</span>
 zip.Open(szBuff, <a class="code" href="classCZipArchive.html">CZipArchive</a>::zipOpenReadOnly); 
 <span class="comment">// zipOpenReadOnly mode is necessary for self extract archives</span>
 for (WORD i = 0; i &lt; zip.GetCount(); i++)
  zip.ExtractFile(i, szDest);

 zip.Close();
 return 0;
 <span class="comment">// this code will not work for the encrypted archives since it is needed</span>
 <span class="comment">// to get the password from the user ( a small addition to the </span>
 <span class="comment">// existing code I suppose )</span>
}
</pre></div><p>
After compiling it and appending a zip archive to it (e.g. with the DOS command: <em> copy /b SelfExtract.exe + ZipFile.zip FinalFile.exe </em>) you have a self extracting archive.<h2><a class="anchor" name="sectExc">
Exceptions</a></h2>
The ZipArchive library mostly uses exceptions to notify about the error occured. The library throws <a class="el" href="classCZipException.html">CZipException</a> to notify about errors specific to the internal zip file processing. In the MFC version <a class="el" href="classCZipException.html">CZipException</a> class is derived from CException whereas in the STL version it is derived from std::exception.<h3><a class="anchor" name="excmfc">
MFC version</a></h3>
The library throws the following exceptions inherited from <code>CException:</code> <code>CMemoryException*</code>, <code>CFileExeption*</code> and <code>CZipException*</code> <em><b>(be sure to delete the object when you done with it)</b></em>. Handling them may be done in the following way:<p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
 <span class="comment">// ...</span>
 <span class="comment">// some operations on the ZipArchive library</span>
}
<span class="keywordflow">catch</span> (CException* e)
{
 <span class="keywordflow">if</span> (e-&gt;IsKindOf( RUNTIME_CLASS( <a class="code" href="classCZipException.html">CZipException</a> )))
 {
  <a class="code" href="classCZipException.html">CZipException</a>* p = (<a class="code" href="classCZipException.html">CZipException</a>*) e;
  <span class="comment">//... and so on </span>
 }
 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e-&gt;IsKindOf( RUNTIME_CLASS( CFileException )))
 {
  CFileException* p = (CFileException*) e;
  <span class="comment">//... and so on </span>
 } 
 <span class="keywordflow">else</span>
 {
  <span class="comment">// the only possibility is a memory exception I suppose</span>
  <span class="comment">//... and so on</span>
 }
 e-&gt;Delete();
}
</pre></div><h3><a class="anchor" name="excstl">
STL version</a></h3>
The library throws exceptions inherited from <code>std::exception</code>. In this case you should catch <code>std::exception</code> object <em><b>(not a pointer to it)</b></em>.<h2><a class="anchor" name="sectMemory">
Creating and extracting archives from/in memory</a></h2>
With the function CZipArchive::Open(CZipMemFile&amp;, int) you can create the archive in memory and then write to disk, e.g.:<p>
<div class="fragment"><pre class="fragment"><a class="code" href="classCZipArchive.html">CZipArchive</a> zip;
<a class="code" href="classCZipMemFile.html">CZipMemFile</a> mf;
<span class="comment">// create archive in memory</span>
zip.<a class="code" href="classCZipArchive.html#a9">Open</a>(mf, CZipArchive::zipCreate);
<span class="comment">// ...</span>
<span class="comment">// add some files to archive here e.g. by calling CZipArchive::AddNewFile</span>
<span class="comment">// ...</span>
zip.<a class="code" href="classCZipArchive.html#a46">Close</a>();
<span class="comment">// write the archive to disk</span>
CZipFile f;
<span class="keywordflow">if</span> (f.Open(<span class="stringliteral">"c:\\temp.zip"</span>, CZipFile::modeWrite|CZipFile::modeCreate, <span class="keyword">false</span>)
{
 <span class="keywordtype">int</span> iLen = mf.<a class="code" href="classCZipMemFile.html#a3">GetLength</a>();
 BYTE* b = mf.<a class="code" href="classCZipMemFile.html#a14">Detach</a>();
 f.<a class="code" href="classCZipMemFile.html#a4">Write</a>(b, iLen);
 f.<a class="code" href="classCZipMemFile.html#a15">Close</a>();
 <span class="comment">// we must free the detached memory</span>
 free(b);
}
</pre></div><p>
You can as well read the archive from disk and then extract files, e.g.:<p>
<div class="fragment"><pre class="fragment">CZipFile f;
<span class="keywordflow">if</span> (f.Open(<span class="stringliteral">"c:\\temp.zip"</span>, CZipFile::modeRead, <span class="keyword">false</span>)
{
 <span class="keywordtype">int</span> iLen = f.GetLength(); 
 BYTE* b = (BYTE*)malloc((UINT)iLen);
 f.Read(b, iLen);
 f.Close();
 <a class="code" href="classCZipMemFile.html">CZipMemFile</a> mf;
 mf.<a class="code" href="classCZipMemFile.html#a13">Attach</a>(b, iLen);
 <a class="code" href="classCZipArchive.html">CZipArchive</a> zip;
 zip.<a class="code" href="classCZipArchive.html#a9">Open</a>(mf);
 <span class="comment">// ...</span>
 <span class="comment">// extract files here from the archive e.g. by calling CZipArchive::ExtractFile</span>
 <span class="comment">// ...</span>
 zip.<a class="code" href="classCZipArchive.html#a46">Close</a>();
}
</pre></div><p>
With functions <code> <a class="el" href="classCZipArchive.html#a16">CZipArchive::AddNewFile(CZipMemFile&amp;, LPCTSTR, int, int, unsigned long)</a> </code> and <code>CZipArchive::ExtractFile(WORD, CZipMemFile&amp;, DWORD)</code> you can add files to archive from memory and extract them to a memory file. Now a bit larger example:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// create the archive in memory with two files inside</span>
<a class="code" href="classCZipMemFile.html">CZipMemFile</a> mf;
<a class="code" href="classCZipArchive.html">CZipArchive</a> zip;
zip.<a class="code" href="classCZipArchive.html#a9">Open</a>(mf, CZipArchive::zipCreate);
zip.<a class="code" href="classCZipArchive.html#a13">AddNewFile</a>(<span class="stringliteral">"c:\\testfile1.txt"</span>);
zip.<a class="code" href="classCZipArchive.html#a13">AddNewFile</a>(<span class="stringliteral">"c:\\testfile2.txt"</span>);
zip.<a class="code" href="classCZipArchive.html#a46">Close</a>();
<span class="comment">//create the archive on disk and add a previously zipped file from memory</span>
zip.<a class="code" href="classCZipArchive.html#a9">Open</a>(<span class="stringliteral">"c:\\test.zip"</span>, CZipArchive::zipCreate);
zip.<a class="code" href="classCZipArchive.html#a13">AddNewFile</a>(mf, <span class="stringliteral">"File1.zip"</span>);
zip.<a class="code" href="classCZipArchive.html#a46">Close</a>();
<span class="comment">// we have now zip-in-zip file on the disk, </span>
<span class="comment">// let's extract the embedded zip file back to memory</span>
zip.<a class="code" href="classCZipArchive.html#a9">Open</a>(<span class="stringliteral">"c:\\test.zip"</span>);
<span class="comment">// reset the contents of the CZipMemFile object</span>
mf.<a class="code" href="classCZipMemFile.html#a6">SetLength</a>(0);
zip.<a class="code" href="classCZipArchive.html#a25">ExtractFile</a>(0, mf);
zip.<a class="code" href="classCZipArchive.html#a46">Close</a>();
<span class="comment">// write the file from memory to disk</span>
CZipFile f;
<span class="keywordflow">if</span> (f.Open(<span class="stringliteral">"c:\\File1.zip"</span>, CZipFile::modeWrite|CZipFile::modeCreate, <span class="keyword">false</span>))
{
 <span class="keywordtype">int</span> iLen = mf.<a class="code" href="classCZipMemFile.html#a3">GetLength</a>();
 BYTE* b = mf.<a class="code" href="classCZipMemFile.html#a14">Detach</a>();
 f.<a class="code" href="classCZipMemFile.html#a4">Write</a>(b, iLen);
 f.<a class="code" href="classCZipMemFile.html#a15">Close</a>();
 <span class="comment">// we must free the detached memory</span>
 free(b);
}
</pre></div><p>
<b>One important thing:</b> when you operate on the archive in memory, you must ensure that CZipMemory object will not be destroyed before calling <a class="el" href="classCZipArchive.html#a46">CZipArchive::Close</a>. In some cases you'll need to construct the object using the <code>new</code> operator, e.g.: <div class="fragment"><pre class="fragment"><span class="comment">// ...</span>
<a class="code" href="classCZipMemFile.html">CZipMemFile</a>* pmf = <span class="keyword">new</span> <a class="code" href="classCZipMemFile.html">CZipMemFile</a>;
zip.<a class="code" href="classCZipArchive.html#a9">Open</a>(*pmf, CZipArchive::zipCreate);
<span class="comment">// ...</span>
zip.<a class="code" href="classCZipArchive.html#a46">Close</a>();
<span class="keyword">delete</span> pmf;
</pre></div><h2><a class="anchor" name="sectCallb">
Action progress notifications (callbacks)</a></h2>
The library has the possibility to notify about the progress of the various actions (see <a class="el" href="classCZipArchive.html#w41">CZipArchive::CallbackType</a>). To use this feature you need to define a new class derived from <a class="el" href="structCZipActionCallback.html">CZipActionCallback</a> or from <a class="el" href="structCZipSpanCallback.html">CZipSpanCallback</a> and override <a class="el" href="structCZipCallback.html#a0">CZipCallback::Callback</a> function. Then you need to declare an object of your class and pass its address to function <a class="el" href="classCZipArchive.html#a6">CZipArchive::SetCallback</a> or <a class="el" href="classCZipArchive.html#a8">CZipArchive::SetSpanCallback</a>. Make sure that the object exists while the library performs the action the functor was assigned to. or tell the library not to use the callback (use the same functions).<h2><a class="anchor" name="sectHelp">
Integrating with MSDN</a></h2>
If you wish to integrate the ZipArchive help system with the MSDN library you need to:<ul>
<li>download from 
<A HREF="http://www.artpol-software.com" target="_blank">the Artpol Software site</A>
 ZipArchive HTML Help documentation or ZipArchive HTML documentation if you don't have it.</li><li>in the latter case you need to compile the html files to the HTML Help format with HTML Web Workshop by Microsoft (at the moment of writing available 
<A HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/htmlhelp/html/hwMicrosoftHTMLHelpDownloads.asp" target="_blank">here</A>)
 and using provided <em>index.hhp</em> file (it is at the same location as ZipArchive html help files)</li><li>now you should have <em>index.chm</em> and <em>index.chi</em> files, rename them if you want to and put them to the directory of your choice</li><li>you need to download a free <b> MSDN Integration Utility</b> by Kirk Stowell; you can download it from 
<A HREF="http://www.codeproject.com/winhelp/msdnintegrator.asp" target="_blank">the Code Project site</A>
or from <A HREF="http://www.artpol-software.com" target="_blank">the Artpol Software site</A> 
 (Download-&gt;ZipArchive)</li><li>use the <b> MSDN Integration Utility</b> for the files you have prepared</li><li>now pressing the F1 key on the ZipArchive library method or class in the Visual Studio brings up the MSDN help; you have also a searchable ZipArchive collection inside MSDN <dl compact><dt><b>Note:</b></dt><dd>After integrating the ZipArchive help system with the MSDN library, you need to be patient when you use the Index for the first time, because it'll be rebuilt then which can be a lengthy process. </dd></dl>
</li></ul>
<hr><address><small>
ZipArchive Copyright &copy;&nbsp;2000-2005 <a href="mailto:tdracz@artpol-software.com"> Tadeusz Dracz </a>. Generated at Fri Aug 5 21:44:52 2005.
</small></address>
</body>
</html>
