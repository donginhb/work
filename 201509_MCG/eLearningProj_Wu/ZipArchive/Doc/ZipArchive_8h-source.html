<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ZipArchive: ZipArchive.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff" leftmargin="32" marginwidth="32" topmargin="32" marginheight="32">
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">D:</a>&nbsp;/&nbsp;<a class="el" href="dir_000001.html">Moje dokumenty</a>&nbsp;/&nbsp;<a class="el" href="dir_000002.html">Visual</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">ZipArchive</a>&nbsp;/&nbsp;<a class="el" href="dir_000004.html">_temp</a>&nbsp;/&nbsp;<a class="el" href="dir_000005.html">ZipArchive</a></div>
<h1>ZipArchive.h</h1><a href="ZipArchive_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">// $RCSfile: ZipArchive.h,v $</span>
00003 <span class="comment">// $Revision: 1.6 $</span>
00004 <span class="comment">// $Date: 2005/08/05 19:37:22 $ $Author: Tadeusz Dracz $</span>
00006 <span class="comment"></span><span class="comment">// This source file is part of the ZipArchive library source distribution and</span>
00007 <span class="comment">// is Copyrighted 2000-2005 by Tadeusz Dracz (http://www.artpol-software.com/)</span>
00008 <span class="comment">// </span>
00009 <span class="comment">// This program is free software; you can redistribute it and/or</span>
00010 <span class="comment">// modify it under the terms of the GNU General Public License</span>
00011 <span class="comment">// as published by the Free Software Foundation; either version 2</span>
00012 <span class="comment">// of the License, or (at your option) any later version.</span>
00013 <span class="comment">// </span>
00014 <span class="comment">// For the licensing details see the file License.txt</span>
00015 <span class="comment">//</span>
00016 <span class="comment">// Check the site http://www.artpol-software.com for the updated version of the library.</span>
00018 <span class="comment"></span><span class="comment">//   </span>
00019 <span class="comment">// The following information files are distributed along with this library:</span>
00020 <span class="comment">//  License.txt  - licensing information</span>
00021 <span class="comment">//  gpl.txt   - General Public License text</span>
00022 <span class="comment">//  Readme.txt  - general information</span>
00023 <span class="comment">//  ChangeLog.txt - revision history</span>
00024 <span class="comment">//  faq.txt   - frequently asked questions</span>
00025 <span class="comment">//  Appnote.txt  - details on the zip format</span>
00026 <span class="comment">//       ( also available at ftp://ftp.pkware.com/appnote.zip)</span>
00027 <span class="comment">//</span>
00028 <span class="comment">// </span>
00029 
00030 
00031 
00038 <span class="preprocessor">#if !defined(AFX_ZIPARCHIVE_H__A7F528A6_1872_4071_BE66_D56CC2DDE0E6__INCLUDED_)</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#define AFX_ZIPARCHIVE_H__A7F528A6_1872_4071_BE66_D56CC2DDE0E6__INCLUDED_</span>
00040 <span class="preprocessor"></span>
00062 <span class="comment">// to ensure that the correct files are copied</span>
00063 <span class="comment">// (see "Compatibility" chapter in the documentation).</span>
00064 <span class="comment">// Rebuild the project after copying the files.</span>
00065 <span class="preprocessor">#ifdef ZIP_ARCHIVE_MFC_PROJ </span>
00066 <span class="preprocessor"></span><span class="preprocessor"> #ifndef ZIP_ARCHIVE_MFC</span>
00067 <span class="preprocessor"></span><span class="preprocessor">  #error You need to copy files from the MFC subdirectory\</span>
00068 <span class="preprocessor">   to the ZipArchive root directory and rebuild the project</span>
00069 <span class="preprocessor"></span><span class="preprocessor"> #endif </span>
00070 <span class="preprocessor"></span><span class="preprocessor">#elif defined ZIP_ARCHIVE_STL_PROJ</span>
00071 <span class="preprocessor"></span><span class="preprocessor"> #ifndef ZIP_ARCHIVE_STL</span>
00072 <span class="preprocessor"></span><span class="preprocessor">  #error You need to copy files from the STL subdirectory\</span>
00073 <span class="preprocessor">   to the ZipArchive root directory and rebuild the project</span>
00074 <span class="preprocessor"></span><span class="preprocessor"> #endif </span>
00075 <span class="preprocessor"></span><span class="preprocessor">#endif //</span>
00076 <span class="preprocessor"></span>
00077 <span class="preprocessor">#if (_MSC_VER &gt; 1000) &amp;&amp; (defined ZIP_HAS_DLL)</span>
00078 <span class="preprocessor"></span><span class="preprocessor"> #pragma warning( disable : 4251 ) // needs to have dll-interface to be used by clients of class</span>
00079 <span class="preprocessor"></span><span class="preprocessor"> #pragma warning( disable : 4275 ) // non dll-interface class used as base for dll-interface</span>
00080 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00081 <span class="preprocessor"></span>
00082 <span class="preprocessor">#ifdef __GNUC__</span>
00083 <span class="preprocessor"></span><span class="preprocessor"> #include "zlib.h"</span>
00084 <span class="preprocessor">#else</span>
00085 <span class="preprocessor"></span><span class="preprocessor"> #include "zlib/zlib.h"</span>
00086 <span class="preprocessor">#endif</span>
00087 <span class="preprocessor"></span>
00088 <span class="preprocessor">#include "<a class="code" href="ZipException_8h.html">ZipException.h</a>"</span>
00089 <span class="preprocessor">#include "<a class="code" href="ZipAutoBuffer_8h.html">ZipAutoBuffer.h</a>"</span>
00090 <span class="preprocessor">#include "<a class="code" href="ZipCentralDir_8h.html">ZipCentralDir.h</a>"</span> 
00091 <span class="preprocessor">#include "<a class="code" href="ZipStorage_8h.html">ZipStorage.h</a>"</span>
00092 <span class="preprocessor">#include "<a class="code" href="ZipPathComponent_8h.html">ZipPathComponent.h</a>"</span>
00093 <span class="preprocessor">#include "ZipString.h"</span>
00094 <span class="preprocessor">#include "ZipExport.h"</span>
00095 
00096 
<a name="l00102"></a><a class="code" href="structCZipAddNewFileInfo.html">00102</a> <span class="keyword">struct </span>ZIP_API CZipAddNewFileInfo
00103 {
00104  CZipAddNewFileInfo(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>)
00105   : m_szFilePath(lpszFilePath),m_bFullPath(bFullPath)
00106  {
00107   m_pFile = NULL;
00108   Defaults();
00109  }
00110  CZipAddNewFileInfo(LPCTSTR lpszFilePath, LPCTSTR lpszFileNameInZip)
00111   : m_szFilePath(lpszFilePath), m_szFileNameInZip(lpszFileNameInZip)
00112  {
00113   m_pFile = NULL;
00114   Defaults();
00115  }
00116  CZipAddNewFileInfo(CZipAbstractFile* pFile, LPCTSTR lpszFileNameInZip)
00117   : m_pFile(pFile), m_szFileNameInZip(lpszFileNameInZip)
00118  {
00119   Defaults();
00120  }
<a name="l00124"></a><a class="code" href="structCZipAddNewFileInfo.html#o0">00124</a>  CZipString m_szFilePath;  
00125 
<a name="l00131"></a><a class="code" href="structCZipAddNewFileInfo.html#o1">00131</a>  CZipString m_szFileNameInZip;
00132  
<a name="l00145"></a><a class="code" href="structCZipAddNewFileInfo.html#o2">00145</a>  <span class="keywordtype">bool</span> m_bFullPath;
00146 
<a name="l00150"></a><a class="code" href="structCZipAddNewFileInfo.html#o3">00150</a>  <span class="keywordtype">int</span> m_iComprLevel;    
00151 
<a name="l00160"></a><a class="code" href="structCZipAddNewFileInfo.html#o4">00160</a>  <span class="keywordtype">int</span> m_iSmartLevel;
00161 
<a name="l00189"></a><a class="code" href="structCZipAddNewFileInfo.html#o5">00189</a>  <span class="keywordtype">int</span> m_iReplaceIndex;  
00190 
<a name="l00194"></a><a class="code" href="structCZipAddNewFileInfo.html#o6">00194</a>  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> m_nBufSize;  
00195 
<a name="l00205"></a><a class="code" href="structCZipAddNewFileInfo.html#o7">00205</a>  CZipAbstractFile* m_pFile;
00206 
00210  <span class="keywordtype">void</span> Defaults();
00211 };
00212 
00213 
<a name="l00219"></a><a class="code" href="classCZipArchive.html">00219</a> <span class="keyword">class </span>ZIP_API CZipArchive  
00220 {
00221  
00222 <span class="keyword">public</span>:
<a name="l00227"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html">00227</a>  <span class="keyword">struct </span>ZIP_API CZipInternalInfo  
00228  {
00229  
00230   CZipInternalInfo()
00231   {
00232    m_iBufferSize = 65536;
00233    m_uUncomprLeft = 0;
00234    m_uComprLeft  = 0;
00235    m_uCrc32 = 0;
00236   }
00237   <span class="keyword">virtual</span> ~CZipInternalInfo(){}
00238 
<a name="l00242"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#a2">00242</a>   <span class="keywordtype">void</span> Init()
00243   {
00244    m_pBuffer.Allocate(m_iBufferSize);
00245   }
00246   <span class="keywordtype">void</span> ReleaseBuf()
00247   {
00248    m_pBuffer.Release();
00249   }
<a name="l00250"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#o0">00250</a>   z_stream m_stream;  
<a name="l00251"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#o1">00251</a>   DWORD m_uUncomprLeft; 
<a name="l00252"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#o2">00252</a>   DWORD m_uComprLeft;  
<a name="l00253"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#o3">00253</a>   DWORD m_uCrc32;   
00254 
<a name="l00262"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#o4">00262</a>   DWORD m_iBufferSize;
00263 
<a name="l00267"></a><a class="code" href="structCZipArchive_1_1CZipInternalInfo.html#o5">00267</a>   <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a> m_pBuffer;
00268  };
00269 
00270  CZipArchive();
00271  <span class="keyword">virtual</span> ~CZipArchive();
00272 
00282  <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespaceZipPlatform.html#a28">SingleToWide</a>(<span class="keyword">const</span> <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a> &amp;szSingle, CZipString&amp; szWide);
00283 
00293  <span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code" href="namespaceZipPlatform.html#a27">WideToSingle</a>(LPCTSTR lpWide, <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a> &amp;szSingle);
00294 
00295 <span class="preprocessor">#ifdef _UNICODE </span>
00296 <span class="preprocessor"></span>
<a name="l00305"></a><a class="code" href="classCZipArchive.html#e2">00305</a>  <span class="keyword">static</span> <span class="keywordtype">void</span> WideConversionUseAnsi(<span class="keywordtype">bool</span> bUseAnsi)
00306  {
00307   g_bWideConversionUseAnsi = bUseAnsi;
00308  }
00309 <span class="preprocessor">#endif</span>
00310 <span class="preprocessor"></span>
<a name="l00321"></a><a class="code" href="classCZipArchive.html#e3">00321</a>  <span class="keyword">static</span> <span class="keywordtype">void</span> ReadBytes(<span class="keywordtype">void</span>* pDestination, <span class="keyword">const</span> <span class="keywordtype">char</span>* pSource, <span class="keywordtype">int</span> iCount)
00322  {
00323   <span class="keywordflow">if</span> (!m_pReadBytes)
00324    <span class="keywordflow">if</span> (ZipCompatibility::IsBigEndian())
00325     m_pReadBytes = ZipCompatibility::ReadBytesBigEndian;
00326    <span class="keywordflow">else</span>
00327     m_pReadBytes = ZipCompatibility::ReadBytesLittleEndian;
00328   m_pReadBytes(pDestination, pSource, iCount);
00329  }
00330 
<a name="l00340"></a><a class="code" href="classCZipArchive.html#e4">00340</a>  <span class="keyword">static</span> <span class="keywordtype">void</span> WriteBytes(<span class="keywordtype">char</span>* pDestination, <span class="keyword">const</span> <span class="keywordtype">void</span>* pSource, <span class="keywordtype">int</span> iCount)
00341  {
00342   <span class="keywordflow">if</span> (!m_pWriteBytes)
00343    <span class="keywordflow">if</span> (ZipCompatibility::IsBigEndian())
00344     m_pWriteBytes = ZipCompatibility::WriteBytesBigEndian;
00345    <span class="keywordflow">else</span>
00346     m_pWriteBytes = ZipCompatibility::WriteBytesLittleEndian;
00347   m_pWriteBytes(pDestination, pSource, iCount);
00348  }
00349 
<a name="l00359"></a><a class="code" href="classCZipArchive.html#e5">00359</a>  <span class="keyword">static</span> <span class="keywordtype">bool</span> CompareBytes(<span class="keyword">const</span> <span class="keywordtype">char</span>* pBuffer, <span class="keyword">const</span> <span class="keywordtype">void</span>* pBytes, <span class="keywordtype">int</span> iCount)
00360  {
00361   <span class="keywordflow">if</span> (!m_pCompareBytes)
00362    <span class="keywordflow">if</span> (ZipCompatibility::IsBigEndian())
00363     m_pCompareBytes = ZipCompatibility::CompareBytesBigEndian;
00364    <span class="keywordflow">else</span>
00365     m_pCompareBytes = ZipCompatibility::CompareBytesLittleEndian;
00366   <span class="keywordflow">return</span> m_pCompareBytes(pBuffer, pBytes, iCount);
00367  }
00377  <span class="keywordtype">bool</span> SetPassword(LPCTSTR lpszPassword = NULL);
00378 
00382  CZipString GetPassword()<span class="keyword">const </span>;
00383 
00400  <span class="keywordtype">void</span> SetAdvanced(<span class="keywordtype">int</span> iWriteBuffer = 65536, <span class="keywordtype">int</span> iGeneralBuffer = 65536, <span class="keywordtype">int</span> iSearchBuffer = 32768);
00401 
<a name="l00405"></a><a class="code" href="classCZipArchive.html#a5">00405</a>  <span class="keywordtype">void</span> GetAdvanced(<span class="keywordtype">int</span>* piWriteBuffer = NULL, <span class="keywordtype">int</span>* piGeneralBuffer = NULL, <span class="keywordtype">int</span>* piSearchBuffer= NULL)
00406  {
00407   <span class="keywordflow">if</span> (piWriteBuffer)
00408    *piWriteBuffer =  m_storage.m_iWriteBufferSize;
00409   <span class="keywordflow">if</span> (piGeneralBuffer)
00410    *piGeneralBuffer = m_info.m_iBufferSize;
00411   <span class="keywordflow">if</span> (piSearchBuffer)
00412    *piSearchBuffer = m_centralDir.m_iBufferSize;
00413  }
00414 
<a name="l00420"></a><a class="code" href="classCZipArchive.html#w41">00420</a>  <span class="keyword">enum</span> CallbackType
00421  {
00422   cbNothing = 0x0000, 
00423   cbAdd  = 0x0001, 
00424   cbAddTmp = 0x0002, 
00425 
00426   cbAddStore = 0x0004, 
00427 
00428 
00429   cbExtract = 0x0008, 
00430 
00431   cbDeleteCnt = 0x0010, 
00432   cbDelete = 0x0020, 
00433 
00434   cbTest  = 0x0040, 
00435   cbSave  = 0x0080, 
00436 
00437   cbGetFromArchive 
00438      = 0x0100, 
00439   cbRename = 0x0200, 
00440   cbReplace = 0x0400,   
00441   cbNextValue = 0x0800, 
00442   
00443 
00444   cbSubActions= cbAddTmp | cbAddStore | cbDeleteCnt | cbReplace,    
00445   cbActions = cbAdd | cbExtract | cbDelete | cbTest | cbSave | cbGetFromArchive | cbRename, 
00446   cbAll  = cbActions | cbSubActions       
00447  };
00448 
00449 
00465  <span class="keywordtype">void</span> SetCallback(<a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback = NULL, <span class="keywordtype">int</span> iWhich = cbAll);
00466 
<a name="l00470"></a><a class="code" href="classCZipArchive.html#a7">00470</a>  <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* GetCallback(CallbackType iWhich)
00471  {
00472   <span class="keywordflow">return</span> m_callbacks.Get(iWhich);
00473  }
00474 
<a name="l00491"></a><a class="code" href="classCZipArchive.html#a8">00491</a>  <span class="keywordtype">void</span> SetSpanCallback(<a class="code" href="structCZipSpanCallback.html">CZipSpanCallback</a>* pCallback = NULL){m_storage.m_pChangeDiskFunc = pCallback;}
00492 
00493 
00494  
<a name="l00499"></a><a class="code" href="classCZipArchive.html#w42">00499</a>  <span class="keyword">enum</span> OpenMode
00500  {
00501   zipOpen,   
00502 
00509   zipOpenReadOnly,
00510   zipCreate,   
00511   zipCreateSpan  
00512  };
00513 
00514 
00515 
00547  <span class="keywordtype">void</span> Open(LPCTSTR szPathName, <span class="keywordtype">int</span> iMode = zipOpen, <span class="keywordtype">int</span> iVolumeSize = 0);
00548 
00549 
00563  <span class="keywordtype">void</span> Open(CZipAbstractFile&amp; af, <span class="keywordtype">int</span> iMode = zipOpen);
00564 
00583  <span class="keywordtype">void</span> SetRootPath(LPCTSTR szPath = NULL);
00584 
00585 
<a name="l00590"></a><a class="code" href="classCZipArchive.html#a12">00590</a>  CZipString GetRootPath()<span class="keyword">const </span>
00591 <span class="keyword"> </span>{
00592   <span class="keywordflow">return</span> m_szRootPath;
00593  }
00594 
<a name="l00604"></a><a class="code" href="classCZipArchive.html#w43">00604</a>  <span class="keyword">enum</span> Smartness
00605  {
00606   zipsmLazy   = 0x0000,  
00607   zipsmCPassDir  = 0x0001,  
00608   zipsmCPFile0  = 0x0002,  
00609   zipsmNotCompSmall = 0x0004,  
00610   zipsmCheckForEff = 0x0008,  
00611 
00612 
00613 
00614 
00615 
00616 
00617   zipsmMemoryFlag  = 0x0010,  
00618 
00619   zipsmCheckForEffInMem = zipsmMemoryFlag | zipsmCheckForEff, 
00620 
00621   zipsmSmartPass = zipsmCPassDir | zipsmCPFile0,   
00622   zipsmSmartAdd = zipsmNotCompSmall | zipsmCheckForEff, 
00623   zipsmSafeSmart = zipsmSmartPass | zipsmNotCompSmall,    
00624   zipsmSmartest = zipsmSmartPass | zipsmSmartAdd,   
00625 
00626   
00627   zipsmInternal01  = 0xf000   
00628 
00629  };
00630 
00631  
00648  <span class="keywordtype">bool</span> AddNewFile(CZipAddNewFileInfo&amp; info);
00649 
00650 
00655  <span class="keywordtype">bool</span> AddNewFile(LPCTSTR lpszFilePath, <span class="keywordtype">int</span> iComprLevel = -1, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>,
00656   <span class="keywordtype">int</span> iSmartLevel = zipsmSafeSmart, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nBufSize = 65536);
00657 
00658 
00662  <span class="keywordtype">bool</span> AddNewFile(LPCTSTR lpszFilePath,
00663         LPCTSTR lpszFileNameInZip,
00664                              <span class="keywordtype">int</span> iComprLevel = -1,                             
00665         <span class="keywordtype">int</span> iSmartLevel = zipsmSafeSmart,
00666                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nBufSize = 65536);
00667 
00671  <span class="keywordtype">bool</span> AddNewFile(<a class="code" href="classCZipMemFile.html">CZipMemFile</a>&amp; mf,
00672         LPCTSTR lpszFileNameInZip,
00673                              <span class="keywordtype">int</span> iComprLevel = -1,                             
00674         <span class="keywordtype">int</span> iSmartLevel = zipsmSafeSmart,
00675                              <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nBufSize = 65536);
00676 
00677 
00678 
00730  <span class="keywordtype">bool</span> OpenNewFile(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a> &amp; header, <span class="keywordtype">int</span> iLevel = Z_DEFAULT_COMPRESSION, LPCTSTR lpszFilePath = NULL, DWORD uInternal = 0);
00731 
00742  <span class="keywordtype">bool</span> WriteNewFile(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, DWORD iSize);
00743 
00744 
00756  <span class="keywordtype">void</span> SetExtraField(<span class="keyword">const</span> <span class="keywordtype">char</span> *pBuf, WORD iSize);
00757 
00768  <span class="keywordtype">bool</span> CloseNewFile(<span class="keywordtype">bool</span> bAfterException = <span class="keyword">false</span>);
00769 
<a name="l00797"></a><a class="code" href="classCZipArchive.html#a21">00797</a>  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, WORD uIndex, <span class="keywordtype">int</span> iReplaceIndex = -1, <span class="keywordtype">bool</span> bKeepSystComp = <span class="keyword">false</span>)
00798  {
00799     
00800   m_info.Init();
00801   <span class="keywordtype">bool</span> bRet;
00802   <span class="keywordflow">try</span>
00803   {
00804    bRet = GetFromArchive(zip, uIndex, iReplaceIndex, bKeepSystComp, GetCallback(cbGetFromArchive));
00805   }
00806   <span class="keywordflow">catch</span>(...)
00807   {
00808    m_info.ReleaseBuf();
00809    <span class="keywordflow">throw</span>;
00810   }
00811   m_info.ReleaseBuf();
00812   <span class="keywordflow">if</span> (bRet &amp;&amp; m_bAutoFlush)
00813    Flush();
00814 
00815   <span class="keywordflow">return</span> bRet;
00816  }
00817 
00829  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, CZipWordArray &amp;aIndexes, <span class="keywordtype">bool</span> bKeepSystComp = <span class="keyword">false</span>);
00830  
<a name="l00845"></a><a class="code" href="classCZipArchive.html#a23">00845</a>  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, CZipStringArray &amp;aNames, <span class="keywordtype">bool</span> bKeepSystComp = <span class="keyword">false</span>)
00846  {
00847   CZipWordArray indexes;
00848   zip.GetIndexes(aNames, indexes);
00849   <span class="keywordflow">return</span> GetFromArchive(zip, indexes, bKeepSystComp);
00850   
00851  }
00852 
00864  <span class="keywordtype">void</span> GetIndexes(<span class="keyword">const</span> CZipStringArray &amp;aNames, CZipWordArray&amp; aIndexes);
00865 
00903  <span class="keywordtype">bool</span> ExtractFile(WORD uIndex, LPCTSTR lpszPath, <span class="keywordtype">bool</span> bFullPath = <span class="keyword">true</span>,
00904   LPCTSTR lpszNewName = NULL, DWORD nBufSize = 65536);
00905 
00906  
00921  <span class="keywordtype">bool</span> ExtractFile(WORD uIndex, <a class="code" href="classCZipMemFile.html">CZipMemFile</a>&amp; mf, <span class="keywordtype">bool</span> bRewind = <span class="keyword">true</span>, DWORD nBufSize = 65536);
00922 
00934  <span class="keywordtype">bool</span> OpenFile(WORD uIndex);
00935 
00946  DWORD ReadFile(<span class="keywordtype">void</span> *pBuf, DWORD iSize);
00947 
00948 
00964  <span class="keywordtype">bool</span> TestFile(WORD uIndex, DWORD uBufSize = 65536);
00965 
00974  <span class="keywordtype">void</span> CloseFileWithNoUpdate();
00975 
00986  <span class="keywordtype">int</span> GetLocalExtraField(<span class="keywordtype">char</span>* pBuf, <span class="keywordtype">int</span> iSize)<span class="keyword">const </span>;
00987 
00997  <span class="keywordtype">int</span> CloseFile(CZipFile &amp;file);
00998 
00999 
01016  <span class="keywordtype">int</span> CloseFile(LPCTSTR lpszFilePath = NULL, <span class="keywordtype">bool</span> bAfterException = <span class="keyword">false</span>);
01017 
01031  <span class="keywordtype">void</span> DeleteFile(WORD uIndex);
01032 
01047  <span class="keywordtype">void</span> DeleteFiles(CZipWordArray &amp;aIndexes);
01048 
01049 
01064  <span class="keywordtype">void</span> DeleteFiles(<span class="keyword">const</span> CZipStringArray &amp;aNames);
01065 
01066 
01074  <span class="keywordtype">bool</span> SetGlobalComment(LPCTSTR lpszComment);
01075 
01076 
01080  CZipString GetGlobalComment()<span class="keyword">const </span>;
01081 
01082 
01092  <span class="keywordtype">bool</span> SetFileComment(WORD uIndex, LPCTSTR lpszComment);
01093 
01097  CZipString GetArchivePath()<span class="keyword">const</span>;
01098 
01107  <span class="keywordtype">int</span> GetCurrentDisk()<span class="keyword">const </span>;
01108 
<a name="l01122"></a><a class="code" href="classCZipArchive.html#a42">01122</a>  <span class="keywordtype">int</span> GetSpanMode()<span class="keyword">const </span>
01123 <span class="keyword"> </span>{
01124   <span class="keywordflow">return</span> m_storage.m_iSpanMode * m_storage.IsSpanMode();
01125  }
01126 
<a name="l01130"></a><a class="code" href="classCZipArchive.html#w44">01130</a>  <span class="keyword">enum</span> FFCaseSens
01131  {
01132   ffDefault,  
01133 
01134 
01135 
01136   ffCaseSens,  
01137 
01138 
01139 
01140   ffNoCaseSens 
01141 
01142 
01143 
01144 
01145  };
01146 
01170  <span class="keywordtype">int</span> FindFile(LPCTSTR lpszFileName, <span class="keywordtype">int</span> iCaseSensitive = ffDefault, <span class="keywordtype">bool</span> bFileNameOnly = <span class="keyword">false</span>);
01171 
01180  <span class="keywordtype">bool</span> GetFileInfo(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a> &amp; fhInfo, WORD uIndex) <span class="keyword">const</span>;
01181 
01182 
<a name="l01189"></a><a class="code" href="classCZipArchive.html#a45">01189</a>  <span class="keywordtype">int</span> GetCount(<span class="keywordtype">bool</span> bOnlyFiles = <span class="keyword">false</span>)<span class="keyword">const </span>
01190 <span class="keyword"> </span>{
01191   <span class="keywordtype">int</span> iTotalCount = m_centralDir.m_headers.GetSize();
01192   <span class="keywordflow">if</span> (bOnlyFiles)
01193   {
01194    <span class="keywordtype">int</span> iCount = 0;
01195    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iTotalCount; i++)
01196     <span class="keywordflow">if</span> (!m_centralDir.m_headers[i]-&gt;IsDirectory())
01197      iCount++;
01198    <span class="keywordflow">return</span> iCount;
01199   }
01200   <span class="keywordflow">else</span>
01201    <span class="keywordflow">return</span> iTotalCount;
01202  }
01203 
<a name="l01207"></a><a class="code" href="classCZipArchive.html#w45">01207</a>  <span class="keyword">enum</span> CloseAfterException
01208  {
01209   afNoException,  
01210   afAfterException, 
01211   afWriteDir   
01212 
01213  };
01214 
01225  <span class="keywordtype">void</span> Close(<span class="keywordtype">int</span> iAfterException = afNoException, <span class="keywordtype">bool</span> bUpdateTimeStamp = <span class="keyword">false</span>);
01226 
01227 
01236  <span class="keywordtype">bool</span> IsClosed(<span class="keywordtype">bool</span> bArchive = <span class="keyword">true</span>)<span class="keyword">const </span>;
01237 
01258  <span class="keywordtype">void</span> Flush();
01259 
01260 
01272  <span class="keywordtype">void</span> SetAutoFlush(<span class="keywordtype">bool</span> bAutoFlush = <span class="keyword">true</span>);
01273  
01274 
<a name="l01280"></a><a class="code" href="classCZipArchive.html#a50">01280</a>  <span class="keywordtype">bool</span> GetAutoFlush()<span class="keyword">const </span>{<span class="keywordflow">return</span> m_bAutoFlush;}
01281 
<a name="l01302"></a><a class="code" href="classCZipArchive.html#a51">01302</a>  <span class="keywordtype">int</span> GetSystemCompatibility()<span class="keyword"> const </span>{<span class="keywordflow">return</span> m_iArchiveSystCompatib;}
01303 
01316  <span class="keywordtype">bool</span> SetSystemCompatibility(<span class="keywordtype">int</span> iSystemComp);
01317 
01332  <span class="keywordtype">void</span> SetFileHeaderAttr(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>&amp; header, DWORD uAttr);
01333 
01334 
<a name="l01341"></a><a class="code" href="classCZipArchive.html#e6">01341</a>  <span class="keyword">static</span> <span class="keyword">const</span> DWORD* GetCRCTable()
01342  {
01343    <span class="keywordflow">return</span> get_crc_table();
01344  }
01345 
<a name="l01352"></a><a class="code" href="classCZipArchive.html#a54">01352</a>  <a class="code" href="classCZipStorage.html">CZipStorage</a>* GetStorage(){<span class="keywordflow">return</span> &amp;m_storage;}
01353 
01354 
<a name="l01362"></a><a class="code" href="classCZipArchive.html#a55">01362</a>  <span class="keywordtype">void</span> SetDetectZlibMemoryLeaks(<span class="keywordtype">bool</span> bDetect)
01363  {
01364   <span class="keywordflow">if</span> (m_iFileOpened != nothing)
01365   {
01366    TRACE(_T(<span class="stringliteral">"CZipArchive::SetDetectZlibMemoryLeaks: Set it before opening a file in the archive"</span>));
01367    <span class="keywordflow">return</span>;
01368   }
01369   m_bDetectZlibMemoryLeaks = bDetect;
01370   
01371  }
01372 
<a name="l01386"></a><a class="code" href="classCZipArchive.html#a56">01386</a>  <span class="keywordtype">void</span> SetConvertAfterOpen (<span class="keywordtype">bool</span> bConvertAfterOpen)
01387  {
01388   <span class="keywordflow">if</span> (!IsClosed())
01389   {
01390    TRACE(_T(<span class="stringliteral">"CZipArchive::SetConvertAfterOpen: Set it before opening the archive"</span>));
01391    <span class="keywordflow">return</span>;
01392   }
01393   m_centralDir.m_bConvertAfterOpen = bConvertAfterOpen;
01394 
01395  }
01396 
01397 
<a name="l01412"></a><a class="code" href="classCZipArchive.html#a57">01412</a>  <span class="keywordtype">void</span> EnableOemConversion(<span class="keywordtype">bool</span> enable)
01413  {
01414   <span class="keywordflow">if</span> (!IsClosed())
01415   {
01416    TRACE(_T(<span class="stringliteral">"CZipArchive::EnableOemConversion: Set it before opening the archive"</span>));
01417    <span class="keywordflow">return</span>;
01418   }
01419   m_centralDir.m_bOemConversion = enable;
01420  }
01421 
01432  <span class="keywordtype">void</span> EnableFindFast(<span class="keywordtype">bool</span> bEnable = <span class="keyword">true</span>);
01433 
01434 
<a name="l01453"></a><a class="code" href="classCZipArchive.html#a59">01453</a>  <span class="keywordtype">int</span> GetFindFastIndex(<span class="keywordtype">int</span> iFindFastIndex)<span class="keyword"> const</span>
01454 <span class="keyword"> </span>{
01455   <span class="keywordflow">if</span> (IsClosed())
01456   {
01457    TRACE(_T(<span class="stringliteral">"CZipArchive::GetFindFastIndex: ZipArchive not yet opened.\n"</span>));
01458    <span class="keywordflow">return</span> -1;
01459   }
01460   
01461   <span class="keywordflow">return</span> m_centralDir.GetFindFastIndex(iFindFastIndex);
01462  }
01463 
01464 
01478  <span class="keywordtype">void</span> SetTempPath(LPCTSTR lpszPath = NULL, <span class="keywordtype">bool</span> bForce = <span class="keyword">true</span>);
01479 
01480 
01481 
<a name="l01485"></a><a class="code" href="classCZipArchive.html#w46">01485</a>  <span class="keyword">enum</span> Predict
01486  {
01487  
01488   prDir,  
01489   prFile, 
01490   prAuto  
01491     
01492  };
01493 
01513  CZipString PredictFileNameInZip(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath, <span class="keywordtype">int</span> iWhat = prAuto, <span class="keywordtype">bool</span> bExactly = <span class="keyword">false</span>)<span class="keyword">const </span>;
01514 
01526  <span class="keywordtype">int</span> WillBeDuplicated(LPCTSTR lpszFilePath, <span class="keywordtype">bool</span> bFullPath, <span class="keywordtype">bool</span> bFileNameOnly = <span class="keyword">false</span>, <span class="keywordtype">int</span> iWhat = prAuto);
01527 
01528 
01539  CZipString PredictExtractedFileName(LPCTSTR lpszFileNameInZip, LPCTSTR lpszPath, <span class="keywordtype">bool</span> bFullPath, LPCTSTR lpszNewName = NULL)<span class="keyword">const </span>;
01540 
<a name="l01547"></a><a class="code" href="classCZipArchive.html#a64">01547</a>  CZipString GetTempPath()<span class="keyword">const </span>
01548 <span class="keyword"> </span>{
01549   <span class="keywordflow">return</span> m_szTempPath;
01550  }
01551 
01558  CZipString TrimRootPath(<a class="code" href="classCZipPathComponent.html">CZipPathComponent</a>&amp; zpc)<span class="keyword">const </span>;
01559 
01571  <span class="keyword">static</span> <span class="keywordtype">bool</span> RemovePathBeginning(LPCTSTR lpszBeginning, CZipString&amp; szPath, ZIPSTRINGCOMPARE pCompareFunction);
01572 
<a name="l01592"></a><a class="code" href="classCZipArchive.html#a66">01592</a>  <span class="keywordtype">void</span> SetCaseSensitivity(<span class="keywordtype">bool</span> bCaseSensitive) 
01593  {
01594   m_bCaseSensitive = bCaseSensitive;
01595   m_pZipCompare = GetCZipStrCompFunc(bCaseSensitive);
01596  }
01597 
01602  <span class="keywordtype">void</span> GetCentralDirInfo(<a class="code" href="structCZipCentralDir_1_1Info.html">CZipCentralDir::Info</a>&amp; info)<span class="keyword">const</span>;
01603  
01604 
<a name="l01610"></a><a class="code" href="classCZipArchive.html#a68">01610</a>  DWORD GetCentralDirSize(<span class="keywordtype">bool</span> bWhole = <span class="keyword">true</span>)<span class="keyword"> const</span>
01611 <span class="keyword"> </span>{
01612   <span class="keywordflow">return</span> m_centralDir.GetSize(bWhole);
01613  }
01614 
<a name="l01619"></a><a class="code" href="classCZipArchive.html#a69">01619</a>  <span class="keywordtype">bool</span> IsReadOnly(){<span class="keywordflow">return</span> m_storage.IsReadOnly();}
01620 
01621 
<a name="l01629"></a><a class="code" href="classCZipArchive.html#a70">01629</a>  <span class="keywordtype">void</span> SetIgnoreCRC(<span class="keywordtype">bool</span> bIgnore = <span class="keyword">true</span>){m_bIgnoreCRC = bIgnore;}
01630 
<a name="l01636"></a><a class="code" href="classCZipArchive_1_1CWildcard.html">01636</a>  <span class="keyword">class </span>ZIP_API CWildcard  
01637  {
01638  <span class="keyword">public</span>:
01639   
01640   
<a name="l01641"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#w12">01641</a>   <span class="keyword">enum</span> Match
01642   {
01643    matchNone,   
01644    matchValid,   
01645    matchEnd,   
01646    matchAbort,   
01647    matchRange,   
01648    matchLiteral,  
01649    matchPattern  
01650   };
01651   
<a name="l01652"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#w13">01652</a>   <span class="keyword">enum</span> Pattern 
01653   {
01654    patternEmpty = -4, 
01655    patternClose,  
01656    patternRange,  
01657    patternEsc,   
01658    patternValid,  
01659   };
01660   
01661   
01673   <span class="keywordtype">bool</span> IsMatch(LPCTSTR lpszText, <span class="keywordtype">int</span>* iRetCode = NULL);
01674 
01682   <span class="keyword">static</span> <span class="keywordtype">bool</span> IsPattern(LPCTSTR lpszPattern);
01683 
01694   <span class="keyword">static</span> <span class="keywordtype">bool</span> IsPatternValid(LPCTSTR lpszPattern, <span class="keywordtype">int</span>* iErrorType = NULL);
01695   
01708   <span class="keyword">static</span> <span class="keywordtype">int</span> Match(LPCTSTR lpszPattern, LPCTSTR lpszText);
01709   
01710   CWildcard(){}
<a name="l01715"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#a2">01715</a>   CWildcard(LPCTSTR lpszPattern, <span class="keywordtype">bool</span> bCaseSensitive)
01716   {
01717    SetPattern(lpszPattern, bCaseSensitive);
01718   }
01719   <span class="keyword">virtual</span> ~CWildcard(){}
01720   
<a name="l01740"></a><a class="code" href="classCZipArchive_1_1CWildcard.html#a4">01740</a>   <span class="keywordtype">void</span> SetPattern(LPCTSTR lpszPattern, <span class="keywordtype">bool</span> bCaseSensitive)
01741   {
01742    m_szPattern = lpszPattern;
01743    m_bCaseSensitive=bCaseSensitive;
01744    <span class="keywordflow">if</span> (!bCaseSensitive)
01745     m_szPattern.MakeLower();
01746   }
01747   operator LPCTSTR()
01748   {
01749    <span class="keywordflow">return</span> (LPCTSTR)m_szPattern;
01750   }
01751  protected:
01752   <span class="keywordtype">bool</span> m_bCaseSensitive;  
01753   static <span class="keywordtype">int</span> MatchAfterStar(LPCTSTR p , LPCTSTR t);
01754   CZipString m_szPattern;
01755  };
01756 
01757 
01774  <span class="keywordtype">void</span> FindMatches(LPCTSTR lpszPattern, CZipWordArray&amp; ar, <span class="keywordtype">bool</span> bFullPath = true)const;
01775 
01776 
01789  <span class="keywordtype">bool</span> RenameFile(WORD uIndex, LPCTSTR lpszNewName);
01790 
<a name="l01798"></a><a class="code" href="classCZipArchive.html#o0">01798</a>  <span class="keywordtype">bool</span> m_bRemoveDriveLetter;
01799 
01800 protected:
01801  
01805  static <span class="keywordtype">void</span> (*m_pReadBytes)(<span class="keywordtype">void</span>*, const <span class="keywordtype">char</span>*, <span class="keywordtype">int</span>);
01806 
01810  static <span class="keywordtype">void</span> (*m_pWriteBytes)(<span class="keywordtype">char</span>*, const <span class="keywordtype">void</span>*, <span class="keywordtype">int</span>);
01811 
01815  static <span class="keywordtype">bool</span> (*m_pCompareBytes)(const <span class="keywordtype">char</span>*, const <span class="keywordtype">void</span>*, <span class="keywordtype">int</span>);
01816 
01822  <span class="keywordtype">void</span> MakeSpaceForReplace(<span class="keywordtype">int</span> iReplaceIndex, DWORD uTotal, LPCTSTR lpszFileName);
<a name="l01827"></a><a class="code" href="structCZipArchive_1_1CZipSmClrPass.html">01827</a>  struct ZIP_API <a class="code" href="structCZipArchive_1_1CZipSmClrPass.html">CZipSmClrPass</a>
01828  {
01829   <span class="keywordtype">void</span> ClearPasswordSmartly(CZipArchive* pZip)
01830   {
01831    m_pZip = pZip;
01832    m_szPass = pZip-&gt;GetPassword();
01833    <span class="keywordflow">if</span> (!m_szPass.IsEmpty())
01834     pZip-&gt;SetPassword();
01835   }
01836   ~CZipSmClrPass()
01837   {
01838    <span class="keywordflow">if</span> (!m_szPass.IsEmpty())
01839     m_pZip-&gt;SetPassword(m_szPass);
01840   }
01841   CZipString m_szPass;
01842   CZipArchive* m_pZip;
01843  };
01844  
<a name="l01849"></a><a class="code" href="structCZipArchive_1_1CZipDeleteInfo.html">01849</a>  <span class="keyword">struct </span>ZIP_API CZipDeleteInfo
01850  {
01851   CZipDeleteInfo(){m_pHeader = NULL; m_bDelete = <span class="keyword">false</span>;}
01852   CZipDeleteInfo(<a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* pHeader, <span class="keywordtype">bool</span> bDelete)
01853    :m_pHeader(pHeader), m_bDelete (bDelete){}
01854   <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* m_pHeader;
01855   <span class="keywordtype">bool</span> m_bDelete;
01856  };
01857 
01858 
<a name="l01863"></a><a class="code" href="structCZipArchive_1_1CZipClbckStrg.html">01863</a>  <span class="keyword">struct </span>ZIP_API CZipClbckStrg : <span class="keyword">public</span> CZipMap&lt;CallbackType, CZipActionCallback*&gt;  
01864  {
01865   <span class="keywordtype">void</span> Set(<a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback, CallbackType iType)
01866   {
01867    <span class="keywordflow">if</span> (pCallback)
01868    {
01869     SetAt(iType, pCallback);
01870    }
01871    <span class="keywordflow">else</span>
01872     RemoveKey(iType);
01873   }
01874   <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* Get(CallbackType iType)
01875   {
01876    <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback = NULL;
01877    <span class="keywordflow">if</span> (Lookup(iType, pCallback))
01878    {
01879     pCallback-&gt;<a class="code" href="structCZipActionCallback.html#o0">m_iType</a> = iType;
01880     <span class="keywordflow">return</span> pCallback;
01881    }
01882    <span class="keywordflow">else</span>
01883     <span class="keywordflow">return</span> NULL;
01884   }
01885  
01886  };
01887  
01888  
<a name="l01892"></a><a class="code" href="classCZipArchive.html#p0">01892</a>  CZipClbckStrg m_callbacks;
01893  
01894 
01898  <span class="keywordtype">void</span> WriteCentralDirectory(<span class="keywordtype">bool</span> bFlush = <span class="keyword">true</span>);
01899 
<a name="l01904"></a><a class="code" href="classCZipArchive.html#p1">01904</a>  <span class="keywordtype">bool</span> m_bCaseSensitive;
01905 
<a name="l01912"></a><a class="code" href="classCZipArchive.html#p2">01912</a>  ZIPSTRINGCOMPARE m_pZipCompare;
01913 
<a name="l01918"></a><a class="code" href="classCZipArchive.html#p3">01918</a>  CZipInternalInfo m_info;
01919 
01920  
<a name="l01925"></a><a class="code" href="classCZipArchive.html#p4">01925</a>  <a class="code" href="classCZipStorage.html">CZipStorage</a> m_storage;
01926 
<a name="l01931"></a><a class="code" href="classCZipArchive.html#p5">01931</a>  <a class="code" href="classCZipCentralDir.html">CZipCentralDir</a> m_centralDir;
01932 
<a name="l01936"></a><a class="code" href="classCZipArchive.html#x4">01936</a>  <span class="keyword">enum</span> OpenFileType
01937  {
01938   extract = -1, 
01939   nothing,  
01940   compress  
01941  };
01942  
<a name="l01946"></a><a class="code" href="classCZipArchive.html#p6">01946</a>  <span class="keywordtype">char</span> m_iFileOpened;
01947 
<a name="l01954"></a><a class="code" href="classCZipArchive.html#p7">01954</a>  <span class="keywordtype">bool</span> m_bAutoFlush;
01955 
<a name="l01959"></a><a class="code" href="classCZipArchive.html#p8">01959</a>  <span class="keywordtype">bool</span> m_bIgnoreCRC;
01960 
01961  
01962 
<a name="l01969"></a><a class="code" href="classCZipArchive.html#p9">01969</a>  CZipString m_szRootPath;
01970 
<a name="l01977"></a><a class="code" href="classCZipArchive.html#p10">01977</a>  CZipString m_szTempPath;
01978 
01979 <span class="preprocessor">#ifdef _UNICODE </span>
01980 <span class="preprocessor"></span>
<a name="l01983"></a><a class="code" href="classCZipArchive.html#t3">01983</a>  <span class="keyword">static</span> <span class="keywordtype">bool</span> g_bWideConversionUseAnsi;
01984 <span class="preprocessor">#endif</span>
01985 <span class="preprocessor"></span>
01993  <span class="keywordtype">void</span> OpenInternal(<span class="keywordtype">int</span> iMode);
01994 
<a name="l02003"></a><a class="code" href="classCZipArchive.html#p11">02003</a>  <span class="keywordtype">int</span> m_iArchiveSystCompatib;
02004 
02009  <span class="keywordtype">void</span> EmptyPtrList();
02010 
02011 
02012 
02018  <span class="keywordtype">void</span> MovePackedFiles(DWORD uStartOffset, DWORD uEndOffset, DWORD uMoveBy, <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback, <span class="keywordtype">bool</span> bForward = <span class="keyword">false</span>);
02019 
02025  <span class="keywordtype">bool</span> RemoveLast(<span class="keywordtype">bool</span> bRemoveAnyway = <span class="keyword">false</span>);
02026 
02030  <span class="keywordtype">bool</span> GetFromArchive(CZipArchive&amp; zip, WORD uIndex, <span class="keywordtype">int</span> iReplaceIndex, <span class="keywordtype">bool</span> bKeepSystComp, <a class="code" href="structCZipActionCallback.html">CZipActionCallback</a>* pCallback);
02031 
02035  <span class="keywordtype">bool</span> UpdateReplaceIndex(<span class="keywordtype">int</span>&amp; iReplaceIndex, LPCTSTR lpszNewFileName);
02036  
02041  <a class="code" href="classCZipFileHeader.html">CZipFileHeader</a>* CurrentFile();
02042 
02049  <span class="keywordtype">void</span> CheckForError(<span class="keywordtype">int</span> iErr);
02050 
02051 
02061  <span class="keywordtype">void</span> <a class="code" href="ZipCentralDir_8h.html#a3">ThrowError</a>(<span class="keywordtype">int</span> err, <span class="keywordtype">bool</span> bZlib = <span class="keyword">false</span>);
02062 
02063 
02064  <span class="keyword">typedef</span> CZipPtrList&lt;void*&gt;::iterator CZipPtrListIter;
<a name="l02065"></a><a class="code" href="classCZipArchive.html#p12">02065</a>  CZipPtrList&lt;void*&gt; m_list; 
02066 
02067 
02068  <span class="keyword">static</span> <span class="keywordtype">void</span>* _zliballoc(<span class="keywordtype">void</span>* opaque, UINT items, UINT size); 
02069  <span class="keyword">static</span> <span class="keywordtype">void</span> _zlibfree(<span class="keywordtype">void</span>* opaque, <span class="keywordtype">void</span>* address); 
02070 
02071  
<a name="l02080"></a><a class="code" href="classCZipArchive.html#p13">02080</a>  <span class="keywordtype">bool</span> m_bDetectZlibMemoryLeaks;
02081 
02082 
<a name="l02086"></a><a class="code" href="classCZipArchive.html#t4">02086</a>  <span class="keyword">static</span> <span class="keyword">const</span> TCHAR m_gszCopyright[];
02087  
02094 
02101  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga14">CryptDecodeBuffer</a>(DWORD uCount);
02107  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga15">CryptEncodeBuffer</a>();
02108 
02113  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga16">CryptEncode</a>(<span class="keywordtype">char</span> &amp;c);
02125  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga17">CryptCryptHeader</a>(<span class="keywordtype">long</span> iCrc, <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a>&amp; buf);
02130  DWORD <a class="code" href="group__Cryptography.html#ga18">CryptCRC32</a>(DWORD l, <span class="keywordtype">char</span> c);
02134  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga19">CryptDecode</a>(<span class="keywordtype">char</span> &amp;c);
02138  <span class="keywordtype">char</span> <a class="code" href="group__Cryptography.html#ga20">CryptDecryptByte</a>();
02139 
02146  <span class="keywordtype">bool</span> <a class="code" href="group__Cryptography.html#ga21">CryptCheck</a>();
02150  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga22">CryptUpdateKeys</a>(<span class="keywordtype">char</span> c);
02154  <span class="keywordtype">void</span> <a class="code" href="group__Cryptography.html#ga23">CryptInitKeys</a>();
<a name="l02158"></a><a class="code" href="group__Cryptography.html#ga0">02158</a>  <a class="code" href="classCZipAutoBuffer.html">CZipAutoBuffer</a> <a class="code" href="group__Cryptography.html#ga2">m_pszPassword</a>;
02159 
<a name="l02165"></a><a class="code" href="group__Cryptography.html#ga1">02165</a>  DWORD <a class="code" href="group__Cryptography.html#ga3">m_keys</a>[3];
02166   
02168 };
02169 
02170 
02171 
02172 <span class="preprocessor">#endif // !defined(AFX_ZIPARCHIVE_H__A7F528A6_1872_4071_BE66_D56CC2DDE0E6__INCLUDED_)</span>
</pre></div><hr><address><small>
ZipArchive Copyright &copy;&nbsp;2000-2005 <a href="mailto:tdracz@artpol-software.com"> Tadeusz Dracz </a>. Generated at Fri Aug 5 21:44:50 2005.
</small></address>
</body>
</html>
